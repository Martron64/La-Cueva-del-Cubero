<!DOCTYPE html>

<html>
<head>
<title>La Cueva del Cubero</title>
</head>

<body>
<h1>
    Bienvenidos
</h1>

<h2>
    como funciona el sistema de dificultad?
</h2>
<h3>
    La dificultad de un cubo de rubik no es medible con un simple "este me costo mas que este", contando la cantidad de piezas o giros, 
    o de una forma lineal, varia dependiendo ciertos parametros, independientes unos de otros.
</h3>
<h3>
    La tabla presentada intenta resolver dicho inconveniente mostrando detalles del cubo:
</h3>
<h4> 
    Nombre: Simplemente el nombre del cubo, aunque algunos tendran una un agregado como lo puede ser "(fd_red)", o "(fd_com)", 
    que significan Fridich reducido y Fridich completo. Esto signofoca que la dificultad a mostrar no es la del cubo en si, 
    sino la de un metodo de resolucion mas dificil que busca resolverlo mas rapido y en menos pasos. De no tener ningun a√±adido, 
    es el metodo principiante
</h4>
<h4> 
    Cantidad de piezas: La cantidad de piezas del cubo de rubik
</h4>
<h4> 
    Tipo de piezas: para las personas que piensen que, en el cubo de rubik clasico, cada cuadrado de color es una pieza unica, que 
    puede ser cambiada por cualquier otra, este apartado puede no tener sentido, pero, por ejemplo, el cubo de rubik 3x3, no presenta
    54 piezas distintas (9 piezas por 6 caras), sino que presenta 26, porque son 6 centros (piezas de un color), 12 aristas (piezas de 
    12 colores) y 8 esquinas (piezas de 3 colores). Con lo que este apartado sirve para saber justamente eso, en cuantos conjuntos se 
    dividen las piezas
</h4>
<h4> 
    Cantidad de giros: La cantidad de centros de giro que presenta el cubo de rubik
</h4>
<h4> 
    Tipos de Giros: Para una persona que nunca haya visto una variacion, esto se debe, a que existen cubos con mas de un tipo de giro. 
    El 3x3 tiene solo 1, pero cubos como el square-one presentan 2 (2 de tipo centro y 2 de tipo de movimiento de cara)
</h4>
<h4> 
    Pasos minimos: Esto depende del metodo utilizado, y determina la cantidad de pasos minimos que presenta parapoder armar un cubo de 
    rubik (el metodo principiante del 3x3 presenta 7, mientras que el Fridich reducido presenta 4)
</h4>
<h4> 
    Cantidad de Algoritmos: Los algoritmos son la base de resolucios de todos (o de al menos mas del %95) los cubos de rubik. Son una
    serie concreta de movimientos que genera un cambio conocido en ciertas piezas, dejando intacta otras que generalmente son las que 
    queremos evitar (el tipico caso de armo una cara, y cuando quiero armar otra desarmo lo que ya hice). Este apartado muestra el 
    minimo de algoritmos nescesarios para poder armar el cubo con cierto metodo
</h4>
<h4> 
    Dificultad promedio de algoritmos: A partir de este punto se empieza a hablar sobre dificultad, aunque este apartado solo dice que 
    tan dificil son, en promedio, los algoritmos utilizador. Para el calculo de dificultad de un algoritmo se va a utilizar la formula
    "(mov_h + mov_a).(mov_mayor/mov_menor)", donde mov_h, son la cantidad de caras que se mueven en sentido horario, mov_a la cantidad 
    que se mueve en anti-horario, mov_mayor son la cantidad de veces que se mueve la cara con mas movimiento, y mov_menor, la cantidad 
    de veces que se mueve la cara con menor movimiento(estos ultimos dos, no es indepentiende de si la cara se mueve en un sentido o 
    en otro, sino que si se mueve mas veces en un sentido, y menos en otro, la cantidad en un sentido puede ser usara como el mayor, 
    y el otro como el menor)
</h4>
<h4> 
    Dificultad Algoritmica total: Aca ya entran detalles como el que puede ser que cuesta mas saberte ciertos algoritmos, y 
    otros, por ser espejados (es decir, si el original dice mover la derecha arriba, y arriba a la izquierda, el espejo dice, mover la
    izquierda arriba, y arriba a la derehca), son mas faciles, con lo que la formula utilizada va a ser "(dif_alg_ori) + 
    (dif_alg_esp)/2", donde dif_alg_org es la suma de las dificultades de los algoritmos originales incluidos los inversos (que es lo 
    mismo a "deshacer" un algoritmo), y dif_alg_esp es la suma de la dificultad de los algoritmos espejos 
</h4>
<h4> 
    Dificultad por Bloqueo: Algunos cubos de rubik pueden llegar a presentar bloqueos, que pueden ser 1 de 4 niveles.
</h4> 
<h5> 
    nivel 0: no bloqueo
</h5>
<h5> 
    nivel 1: hay que "alinear" el cubo para girar (ej: pentacle, square-one, polarir)
</h5>
<h5> 
    nivel 2: Alguna piezas se bloquean en ciertos casos (ej:Puppet V2)
</h5>
<h5> 
    nivel 3: hay piezas que solo se pueden mover a traves de algoritmos (ej: Puppet V1)
</h5>
<h4> 
    La dificultad se calcula con e^2n-1, con n siendo el nivel.
</h4> 
<h4> 
    Dificultad por Deformacion: Hay cubos de rubik que presentan deformaciones, o que presentan siertos patrones en sus piezas
    que aumentan su dificultad, (como el cubo sudoku), donde al igual que el anterior, hay de 4 niveles.
</h4> 
<h5> 
    nivel 0: no deformacion
</h5>
<h5> 
    nivel 1: deformacion minima, pero sigue manteniendo en cierto aspecto la forma original (ej: ficher 3x3)
</h5>
<h5> 
    nivel 2: ya deja de tener su forma original, pero es medianamente facil determinar cuales son cada pieza, y su tipo (ej: axis 3x3)
</h5>
<h5> 
    nivel 3: ya se confunden las piezas, no el tipo, pero es dificil diferenciar, por ejemplo, una esquina de otra (ej: ghost 3x3, 
    sudoku 3x3) 
</h5>
<h4> 
    La dificultad se calcula con e^2n-1, con n siendo el nivel.
</h4>
<h4> 
    Dificultad por Paridad: Es pociblemente el apartado que menos dificultad otorga al cubo de rubik, y ocurre cuando es una variacion de 
    otro cubo, como el 4x4 variacion del 3x3, por ejemplo, al llegar a la etapa de la cruz amarilla, en el 3x3 es imposible que solo 
    esten dadas "vuelta" solo 1 o 3 aristas, o son ninguna, o son 2, o son 4, sin embargo, el 4x4 puede presentar cualquiera de los dos 
    casos "impocibles. El calculo de la dificultad es "alg_parid/cant_parid", donde alg_parid son los algoritmos que resuelven la paridad
    , y cant_parid la cantidad de paridades
</h4> 
<h4> 
    Dificultad total: Dada por "Dificultad_algoritmica_total + dificultad_por_cloqueo + dificultad_por_deformacion + 
    dificultad_por_paridad"
</h4> 
<h2>
    tabla de dificultad
</h2>
<label>
Buscar cubo:
<input type="text" id="buscador" placeholder="3x3, 4x4, mirror...">
</label>
<label>
  Ordenar por:
  <select id="Tipo">
    <option value="DifTot">Dificultad total </option>
    <option value="DifAlg">Dificultad algoritmica </option>
    <option value="DifBlock">Dificultad por bloqueo </option>
    <option value="DifDeform">Dificultad por deformacion </option>
    <option value="DifParid">Dificultad por paridad </option>
    <option value="CantPiezas">Cantidad de piezas </option>
    <option value="CantGiros">Cantidad de giros </option>
    <option value="CantAlg">cantidad de algoritmos </option>
    <option value="Nombre">Nombre </option>
  </select>
</label><label>
  Orden:
  <select id="Orden">
    <option value="Des">Descendente</option>
    <option value="Asc">Ascendente </option>
  </select>
</label>
<div id="contenedorTabla">

<table id="tablaCubos">
  <tr>
    <th>Nombre</th>
    <th>cantidad de piezas</th>
    <th>tipos de piezas</th>
    <th>cantidad de giros</th>
    <th>tipos de giros</th>
    <th>pasos minimos</th>
    <th>cantidad de algoritmos</th>
    <th>dificultad promedio algoritmica</th>
    <th>dificultad algoritmica total</th>
    <th>dificultad por bloqueo</th>
    <th>dificultad por deformacion</th>
    <th>dificultad por paridad</th>
    <th>dificultad total del cubo</th>
    <th>Ver cubo</th>
  </tr>
</table>
</div>
<div id="detalleCubo" hidden>
  <div id="detalleHeader"></div>
  <div id="detalleContenido"></div>
  <div id="detalleFooter"></div>
</div> 
<h1 style="color:white">.</h1>
<h1 style="color:white">.</h1>
<h1 style="color:white">.</h1>
<h1 style="color:white">.</h1>
<h1 style="color:white">.</h1>
<h1 style="color:white">.</h1>
<h1 style="color:white">.</h1>
<script src="./app.js" defer></script>
</body>    
</html>

















